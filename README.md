# Novel RPG Game

Transform any novel into an interactive role-playing game experience using AI-powered storytelling.

## What's New

### Version 2.0 - Major Improvements

- **Action Choice System**: Players now choose from AI-generated options instead of dice rolls
- **Book Quote Integration**: Configurable use of authentic dialogue and narrative from source novels
- **Contextual Dialogue Grouping**: Character dialogue from the same book sections for natural conversations
- **Character Name Display**: Clear identification of characters and players throughout game logs
- **Conclusion Test Framework**: Validate LLM's ability to identify book conclusions accurately
- **Ending Variation Test Framework**: Compare story cohesion across original, opposite, and random endings
- **Enhanced Metadata**: Comprehensive tracking of quote usage, content sources, and dialogue context

## Overview

The Novel RPG Game is an innovative application that analyzes text novels and creates dynamic, turn-based RPG experiences. Using Large Language Models (LLMs), the system extracts key story elements and generates multiple possible endings, allowing 1-4 human players (with AI companions) to influence the narrative through choice-based gameplay.

## Features

- **Novel Analysis**: Automatically extracts main characters, plot points, and narrative structure
- **Dynamic Storytelling**: AI-generated content that adapts to player choices
- **Action Choice System**: Players choose between talk, act, or do nothing options generated by AI
- **Book Quote Integration**: Configurable percentage of authentic dialogue and narrative from source novel
- **Contextual Dialogue Grouping**: Character dialogue from the same book sections for natural conversations
- **Character Name Display**: Clear identification of characters and players in all game logs
- **Multiple Endings**: 8 different story conclusions including original, similar, opposite, and random variants
- **Turn-Based Gameplay**: Choice-based mechanics determine player actions
- **Automated Testing**: Built-in frameworks for analyzing story cohesion and conclusion identification
- **Persistent Game State**: All game sessions are saved with complete story logs and metadata

## Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd novel-rpg-game
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```

3. **Set up environment variables**
   ```bash
   cp .env.example .env
   # Edit .env with your LLM API keys
   ```

4. **Configure the application**
   ```bash
   # Edit config.json with your preferred settings
   ```

5. **Build the application**
   ```bash
   npm run build
   ```

## Configuration

### Environment Variables (.env)
```env
OPENAI_API_KEY=your_openai_api_key_here
# Add other LLM provider keys as needed
```

### Application Configuration (config.json)
```json
{
  "llm": {
    "provider": "openai",
    "model": "gpt-4",
    "apiKey": "${OPENAI_API_KEY}",
    "maxTokens": 2000,
    "temperature": 0.7,
    "timeout": 30000
  },
  "game": {
    "defaultRounds": 15,
    "maxPlayers": 4,
    "turnTimeoutSeconds": 60,
    "gameStateDirectory": "./game_states",
    "maxNovelSizeMB": 50
  },
  "testing": {
    "outputDirectory": "./test_outputs",
    "cohesionAnalysisModel": "gpt-4",
    "testIterations": 6
  }
}
```

## Usage

### Interactive Game Mode

Start a new interactive game:
```bash
npm start
```

Or using development mode:
```bash
npm run dev
```

The application will guide you through:
1. **Novel Selection**: Choose a text file (.txt, .md) up to 50MB
2. **Player Setup**: Specify 1-4 human players (AI fills remaining slots)
3. **Game Configuration**: Set rounds (10-20) and quote percentage (0-100%)
4. **Character Selection**: Players choose from extracted main characters
5. **Gameplay**: Turn-based action selection and story generation

### Testing Mode

Run automated cohesion analysis:
```bash
npm start -- --test --file path/to/novel.txt
```

Or:
```bash
npm run dev -- --test --file path/to/novel.txt
```

#### Conclusion Test Framework
Test LLM's ability to correctly identify book conclusions:
```bash
npx ts-node run-conclusion-test.ts path/to/novel.txt [iterations]
```

This will:
- Analyze the novel multiple times (default: 5 iterations)
- Extract and compare conclusions for consistency
- Score each conclusion for accuracy, completeness, and coherence
- Generate reports in CSV, JSON, and text formats

#### Ending Variation Test Framework
Compare story cohesion across different ending types:
```bash
npx ts-node run-ending-variation-test.ts path/to/novel.txt [rounds] [quotePercentage]
```

This will:
- Generate three distinct endings: original, opposite, and random
- Run three separate games (5 rounds each by default)
- Apply book quote integration at specified percentage
- Analyze cohesion scores for each ending type
- Generate comparative reports showing which ending achieves highest cohesion
- Create individual game state files for each ending variation

### Command Line Options

- `--test` or `-t`: Run in testing mode
- `--file <path>` or `-f <path>`: Specify novel file for testing mode

## Game Mechanics

### Action Choice System
Players are presented with AI-generated options for each turn:
- **Talk Option**: ~200 words of character dialogue
- **Act Option**: ~100 words of narrative action
- **Do Nothing**: Skip turn and add 1 round to game

The system intelligently generates options based on:
- Current game context and story progression
- Character personalities and relationships
- Target ending compatibility
- Book quote availability (if configured)

### Book Quote Integration
Configure the percentage of authentic book content vs. AI-generated content:
- **Quote Percentage**: 0-100% (configurable in game state)
- **Dialogue Quotes**: Actual character dialogue from source novel
- **Action Quotes**: Narrative descriptions of character actions
- **Contextual Grouping**: Quotes from same book sections for coherent conversations
- **Ending Compatibility**: Automatic adjustment for non-original endings
- **Fallback**: AI generation when suitable quotes unavailable

### Story Generation
- Each action generates content targeting one of 8 possible endings
- Content adapts to player choices and character selections
- All generated content is marked as "Book Quote" or "LLM Generated"
- Character names displayed alongside player numbers in all logs
- All generated content is immediately saved to game state files

### Ending Types
1. **Original** (1): Matches the source novel's conclusion
2. **Similar** (3): 80% similar to original ending
3. **Opposite** (1): Direct opposite of original ending
4. **Random** (3): Completely alternative conclusions

## File Structure

```
novel-rpg-game/
├── src/
│   ├── config/          # Configuration management
│   ├── core/            # Game managers and flow control
│   ├── models/          # Data models and interfaces
│   ├── services/        # LLM, analysis, and game services
│   │   ├── ActionChoiceManager.ts    # Action option generation
│   │   ├── BookQuoteExtractor.ts     # Book quote extraction
│   │   └── ...
│   ├── testing/         # Automated testing frameworks
│   │   ├── TestFramework.ts                    # Legacy cohesion testing
│   │   ├── ConclusionTestFramework.ts          # Conclusion identification testing
│   │   └── EndingVariationTestFramework.ts     # Ending comparison testing
│   ├── ui/              # Command-line interface
│   └── index.ts         # Main application entry point
├── game_states/         # Saved game sessions
├── test_outputs/        # Testing mode results
├── TestNovels/          # Sample novels for testing
├── run-conclusion-test.ts           # CLI for conclusion tests
├── run-ending-variation-test.ts     # CLI for ending variation tests
├── config.json          # Application configuration
├── .env                 # Environment variables
└── package.json         # Project dependencies
```

## Output Files

### Game State Files
Format: `DateTime-numberOfPlayers-novelTitle-rounds.txt`
Contains:
- Novel analysis results
- Player selections and character assignments
- Complete turn-by-turn game log with character names
- Generated story content with source marking (Book Quote vs LLM Generated)
- Book quote metadata (chapter, page, context)
- Quote usage statistics
- Final ending achieved

### Test Reports

#### Cohesion Analysis Reports
Generated in multiple formats:
- **CSV**: `cohesion-report-timestamp.csv`
- **Table**: `cohesion-report-timestamp.txt`
- **JSON**: `cohesion-report-timestamp.json`

#### Conclusion Test Reports
Generated in multiple formats:
- **CSV**: `conclusion-test-timestamp.csv` - Iteration-by-iteration results
- **JSON**: `conclusion-test-timestamp.json` - Complete test data
- **Text**: `conclusion-test-timestamp.txt` - Formatted summary

#### Ending Variation Reports
Generated in multiple formats:
- **CSV**: `ending-variation-timestamp.csv` - Comparative statistics
- **JSON**: `ending-variation-timestamp.json` - Complete game data
- **Text**: `ending-variation-timestamp.txt` - Analysis summary

## API Reference

### Main Classes

#### GameManager
Central orchestrator for game sessions
```typescript
const gameManager = new GameManager();
const session = await gameManager.startGame(novelFile, humanPlayers, rounds);

// New action choice system
const storySegment = await gameManager.processPlayerTurnWithChoice(playerId);

// Legacy method (deprecated)
const storySegment = await gameManager.processPlayerTurn(playerId, action);
```

#### ActionChoiceManager
Generates and manages player action options
```typescript
const actionChoiceManager = createActionChoiceManager(llmService, bookQuoteExtractor, novelText);
const options = await actionChoiceManager.generateActionOptions(player, gameContext);
const choice = await actionChoiceManager.presentOptionsToPlayer(player, options);
const segment = await actionChoiceManager.applyPlayerChoice(choice, gameContext);
```

#### BookQuoteExtractor
Extracts authentic content from source novel
```typescript
const bookQuoteExtractor = createBookQuoteExtractor(novelText, novelAnalysis, llmService);
const dialogue = await bookQuoteExtractor.extractCharacterDialogue(character, context, targetEnding);
const actions = await bookQuoteExtractor.extractCharacterActions(character, context, targetEnding);
const compatibility = await bookQuoteExtractor.checkEndingCompatibility(quote, targetEnding);
```

#### ConclusionTestFramework
Tests LLM conclusion identification accuracy
```typescript
const conclusionTest = new ConclusionTestFramework(gameManager);
const report = await conclusionTest.runConclusionTest(config);
```

#### EndingVariationTestFramework
Compares story cohesion across ending types
```typescript
const endingTest = new EndingVariationTestFramework(gameManager);
const report = await endingTest.runEndingVariationTest(config);
```

#### TestFramework
Automated testing and cohesion analysis (legacy)
```typescript
const testFramework = new TestFramework();
const report = await testFramework.runAutomatedTests(novelFile);
```

#### GameUI
Command-line interface management
```typescript
const gameUI = new GameUI();
const params = await gameUI.setupGame();
```

## Error Handling

The application provides comprehensive error handling with specific exit codes:

- **0**: Success
- **1**: Configuration error
- **2**: Input validation error
- **3**: Novel analysis error
- **4**: Game runtime error
- **5**: Unexpected error
- **6**: User interruption

## Troubleshooting

### Common Issues

1. **"Configuration validation failed"**
   - Check your `config.json` file format
   - Verify environment variables in `.env`
   - Ensure API keys are valid

2. **"Novel analysis failed"**
   - Verify novel file exists and is readable
   - Check file size (must be under 50MB)
   - Ensure LLM service is accessible

3. **"Story ending generation failed"**
   - Usually indicates LLM service issues
   - Check API key validity and rate limits
   - Verify network connectivity

### Debug Mode

For detailed logging, set environment variable:
```bash
DEBUG=1 npm start
```

## Development

### Running Tests
```bash
npm test
```

### Watch Mode
```bash
npm run test:watch
```

### Building
```bash
npm run build
```

### Cleaning
```bash
npm run clean
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Submit a pull request

## License

MIT License - see LICENSE file for details

## Support

For issues and questions:
1. Check the troubleshooting section
2. Review error messages and exit codes
3. Examine log files in game_states/ directory
4. Create an issue with detailed error information